<?php
// Malware Scanner module for SecureSphere
class SecureSphere_MalwareScanner {
    private static $scan_results = [];
    // private static $yara_rules = []; // Deprecating direct YARA rules in code, will use DB.

    // Option keys
    const OPT_SCAN_UPLOADS_ENABLED = 'securesphere_malware_scan_uploads_enabled';
    const OPT_SCHEDULE_ENABLED = 'securesphere_malware_schedule_enabled';
    const OPT_SCHEDULE_FREQUENCY = 'securesphere_malware_schedule_frequency';
    const OPT_CUSTOM_REGEX_PATTERNS = 'securesphere_malware_custom_regex';
    const OPT_KNOWN_MALWARE_HASHES = 'securesphere_malware_known_hashes'; // For placeholder
    const OPT_LAST_SCAN = 'securesphere_last_scan';

    public static function init() {
        self::load_settings_and_hooks();
        // self::load_yara_rules(); // Deprecated, signatures will be loaded from DB per scan
    }
    
    private static function load_settings_and_hooks() {
        // Settings
        $scan_uploads_enabled = get_option(self::OPT_SCAN_UPLOADS_ENABLED, true);
        $schedule_enabled = get_option(self::OPT_SCHEDULE_ENABLED, true);

        if ($schedule_enabled) {
            add_action('admin_init', [__CLASS__, 'schedule_scan_job']); // Renamed for clarity
            add_action('securesphere_scheduled_scan_hook', [__CLASS__, 'perform_full_scan']); // Renamed for clarity
        } else {
            // Unschedule if disabled
            if (wp_next_scheduled('securesphere_scheduled_scan_hook')) {
                wp_clear_scheduled_hook('securesphere_scheduled_scan_hook');
            }
        }
        
        if ($scan_uploads_enabled) {
            add_filter('wp_handle_upload', [__CLASS__, 'scan_uploaded_file_filter'], 10, 2); // Renamed for clarity
        }
        
        // Admin menu
        add_action('admin_menu', [__CLASS__, 'add_malware_scan_menu']); // Renamed for clarity
        
        // Manual scan handler
        add_action('admin_post_securesphere_run_manual_scan', [__CLASS__, 'handle_manual_scan_trigger']); // Renamed

        // Signature update hook
        add_action('securesphere_daily_signature_update_hook', [__CLASS__, 'fetch_and_update_signatures_from_file']);
        // Schedule signature updates
        if (!wp_next_scheduled('securesphere_daily_signature_update_hook')) {
            wp_schedule_event(time(), 'daily', 'securesphere_daily_signature_update_hook');
        }
    }

    public static function schedule_scan_job() {
        if (!wp_next_scheduled('securesphere_scheduled_scan_hook')) {
            $frequency = get_option(self::OPT_SCHEDULE_FREQUENCY, 'daily'); // e.g., 'hourly', 'twicedaily', 'daily'
            wp_schedule_event(time(), $frequency, 'securesphere_scheduled_scan_hook');
        }
    }

    public static function fetch_and_update_signatures_from_file() {
        global $wpdb;
        $table_name = $wpdb->prefix . 'securesphere_malware_signatures';
        $json_file_path = SECURESPHERE_PLUGIN_DIR . 'signatures/latest_signatures.json';

        if (!file_exists($json_file_path)) {
            error_log('SecureSphere Signature Update: JSON file not found at ' . $json_file_path);
            set_transient('securesphere_sig_update_status', 'error_file_not_found', HOUR_IN_SECONDS);
            return false;
        }

        $json_content = file_get_contents($json_file_path);
        if ($json_content === false) {
            error_log('SecureSphere Signature Update: Could not read JSON file.');
            set_transient('securesphere_sig_update_status', 'error_file_read', HOUR_IN_SECONDS);
            return false;
        }

        $signatures = json_decode($json_content, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            error_log('SecureSphere Signature Update: Invalid JSON in signatures file. Error: ' . json_last_error_msg());
            set_transient('securesphere_sig_update_status', 'error_json_invalid', HOUR_IN_SECONDS);
            return false;
        }

        if (empty($signatures) || !is_array($signatures)) {
            error_log('SecureSphere Signature Update: No signatures found or invalid format in JSON file.');
            set_transient('securesphere_sig_update_status', 'error_no_signatures_in_file', HOUR_IN_SECONDS);
            return false;
        }

        $updated_count = 0;
        $inserted_count = 0;
        $current_time = current_time('mysql');

        foreach ($signatures as $signature) {
            if (empty($signature['signature_id']) || empty($signature['type']) || empty($signature['pattern']) || empty($signature['date_added'])) {
                error_log('SecureSphere Signature Update: Skipping invalid signature entry: ' . print_r($signature, true));
                continue;
            }

            $data = [
                'type' => sanitize_text_field($signature['type']),
                'pattern' => $signature['pattern'], // Pattern can be complex, sanitize carefully or trust source
                'description' => isset($signature['description']) ? sanitize_textarea_field($signature['description']) : '',
                'severity' => isset($signature['severity']) ? sanitize_text_field($signature['severity']) : 'medium',
                'date_added' => gmdate('Y-m-d H:i:s', strtotime($signature['date_added'])), // Ensure GMT
                'last_updated' => $current_time
            ];
            $where = ['signature_id' => sanitize_text_field($signature['signature_id'])];

            $existing = $wpdb->get_row($wpdb->prepare("SELECT id FROM $table_name WHERE signature_id = %s", $where['signature_id']));

            if ($existing) {
                $result = $wpdb->update($table_name, $data, $where);
                if ($result !== false) $updated_count++;
            } else {
                $data['signature_id'] = $where['signature_id']; // Add signature_id for insert
                $result = $wpdb->insert($table_name, $data);
                if ($result !== false) $inserted_count++;
            }

            if ($result === false) {
                 error_log('SecureSphere Signature Update: DB error for signature ID ' . $where['signature_id'] . ' - ' . $wpdb->last_error);
            }
        }

        update_option('securesphere_last_signature_update_time', $current_time);
        update_option('securesphere_signature_version', 'file_' . date('YmdHis', filemtime($json_file_path))); // Basic versioning
        set_transient('securesphere_sig_update_status', "success_inserted_{$inserted_count}_updated_{$updated_count}", HOUR_IN_SECONDS);
        error_log("SecureSphere Signature Update: Success. Inserted: {$inserted_count}, Updated: {$updated_count}");
        return true;
    }

    public static function perform_full_scan() {
        self::$scan_results = [];
        // Potentially trigger signature update before scan if it hasn't run recently, or rely on daily cron
        // self::fetch_and_update_signatures_from_file();

        $wp_root = ABSPATH;
        
        // Scan core WordPress files
        self::scan_directory($wp_root . 'wp-admin');
        self::scan_directory($wp_root . 'wp-includes');
        
        // Scan themes
        $themes_dir = get_theme_root();
        self::scan_directory($themes_dir);
        
        // Scan plugins
        $plugins_dir = WP_PLUGIN_DIR;
        self::scan_directory($plugins_dir);
        
        // Scan uploads
        $uploads_dir = wp_upload_dir()['basedir'];
        self::scan_directory($uploads_dir);

        // Check for outdated components
        self::check_outdated_components();

        // Check core file integrity
        self::check_core_file_integrity();
        
        // Save scan results
        update_option(self::OPT_LAST_SCAN, [
            'time' => current_time('mysql'),
            'results' => self::$scan_results,
            'type' => 'scheduled'
        ]);
        
        // Send alert if malware found
        if (!empty(self::$scan_results)) { // Changed from has_malware() for direct check
            do_action('securesphere_malware_detected', self::$scan_results);
        }
    }
    
    public static function handle_manual_scan_trigger() {
        if (!current_user_can('manage_options')) {
            wp_die('Permission denied.');
        }
        check_admin_referer('securesphere_run_manual_scan_nonce', 'securesphere_manual_scan_nonce');

        self::perform_full_scan(); // Re-use the full scan logic
        
        // Update last scan type for manual
         $last_scan_data = get_option(self::OPT_LAST_SCAN, []);
         $last_scan_data['type'] = 'manual';
         $last_scan_data['time'] = current_time('mysql'); // Update time for manual scan
         update_option(self::OPT_LAST_SCAN, $last_scan_data);

        wp_redirect(admin_url('admin.php?page=securesphere-malware-scan&scan_status=completed'));
        exit;
    }


    public static function scan_directory($dir) {
        if (!is_dir($dir)) {
            return;
        }

        $files = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($dir, RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($files as $file) {
            if ($file->isFile()) {
                self::scan_file($file->getPathname());
            }
        }
    }

    public static function scan_file($file_path) {
        // Skip non-PHP files unless they're in uploads
        if (!preg_match('/\.(php|phtml|php3|php4|php5|php7|phps|inc)$/i', $file_path) 
            && strpos($file_path, wp_upload_dir()['basedir']) === false) {
            return;
        }

        $relative_path = str_replace(ABSPATH, '', $file_path);
        $content = null; // Initialize content to null
        $file_md5_hash = null;
        $file_sha256_hash = null;

        $signatures = self::load_signatures_from_db();
        if (empty($signatures)) {
            // Optionally log that no signatures are available
            // error_log("SecureSphere Malware Scanner: No signatures loaded.");
            // Fallback to old custom regex and hardcoded patterns if desired, or just return.
            // For now, let's try to keep it clean and rely on the new system.
            // We can re-add custom regex from options as a specific signature type if needed.
            return;
        }

        foreach ($signatures as $signature) {
            $match_found = false;
            $details = '';

            if ($signature['type'] === 'md5_hash') {
                if ($file_md5_hash === null) $file_md5_hash = md5_file($file_path);
                if ($file_md5_hash === $signature['pattern']) {
                    $match_found = true;
                }
            } elseif ($signature['type'] === 'sha256_hash') {
                if ($file_sha256_hash === null) $file_sha256_hash = hash_file('sha256', $file_path);
                if ($file_sha256_hash === $signature['pattern']) {
                    $match_found = true;
                }
            } elseif ($signature['type'] === 'regex') {
                if ($content === null) { // Load content only if needed for regex
                    $content = file_get_contents($file_path);
                    if ($content === false) {
                        // error_log("SecureSphere Malware Scanner: Could not read file content for {$file_path}");
                        continue; // Skip this signature if content cannot be read
                    }
                }
                if (preg_match($signature['pattern'], $content)) {
                    $match_found = true;
                }
            }

            if ($match_found) {
                self::$scan_results[] = [
                    'file' => $relative_path,
                    'type' => 'signature_match', // Generic type for new system
                    'severity' => $signature['severity'],
                    'details' => esc_html($signature['description']) . ' (ID: ' . esc_html($signature['signature_id']) . ')',
                    'signature_id' => $signature['signature_id']
                ];
                // Optimization: if a critical hash match is found, perhaps stop further scanning for this file?
                // For now, let it find all matches.
            }
        }

        // Keep custom regex patterns from options for now, as a fallback or additional check
        // This could be migrated into the signature DB as type 'custom_regex_user' later.
        if ($content === null && (get_option(self::OPT_CUSTOM_REGEX_PATTERNS) || self::has_hardcoded_suspicious_patterns(''))) {
            // Load content if not already loaded and custom/hardcoded patterns exist
             $content = file_get_contents($file_path);
             if ($content === false) $content = ""; // Ensure content is a string
        }

        // Check for hardcoded suspicious patterns (base set) - consider deprecating or moving to DB
        if ($content !== null && self::has_hardcoded_suspicious_patterns($content)) {
            self::$scan_results[] = [
                'file' => $relative_path,
                'type' => 'suspicious_pattern_hardcoded', // Keep type distinct for now
                'severity' => 'medium',
                'details' => 'Contains built-in suspicious patterns.'
            ];
        }
        
        // Check for custom regex patterns from options - consider deprecating or moving to DB
        $custom_patterns = get_option(self::OPT_CUSTOM_REGEX_PATTERNS, []);
        if (!empty($custom_patterns) && is_array($custom_patterns)) {
            foreach($custom_patterns as $idx => $custom_pattern) {
                if (!empty(trim($custom_pattern))) {
                    // Basic validation if it's a valid regex
                    if (@preg_match(trim($custom_pattern), '') !== false) {
                         if (preg_match(trim($custom_pattern), $content)) {
                            self::$scan_results[] = [
                                'file' => $relative_path,
                                'type' => 'suspicious_pattern_custom',
                                'severity' => 'medium', // Or allow severity per custom pattern
                                'details' => 'Matched custom regex pattern #' . ($idx + 1) . ': ' . esc_html(trim($custom_pattern))
                            ];
                        }
                    }
                }
            }
        }
    }

    public static function scan_uploaded_file_filter($file_array, $context) { // Renamed
        // Reset scan results for this specific file scan
        $initial_scan_results_count = count(self::$scan_results);
        
        self::scan_file($file_array['file']);
        
        // Check if new results were added for this file
        $new_findings = array_slice(self::$scan_results, $initial_scan_results_count);

        if (!empty($new_findings)) {
            // Log the specific finding for the uploaded file
            // For simplicity, we'll use the first new finding as the reason
            $reason = $new_findings[0]['details'] ?? 'Malware detected in upload';
            
            // Remove the uploaded file
            @unlink($file_array['file']);
            
            // Add to main scan log if needed, or a separate upload log
            // For now, the findings are in self::$scan_results which might be confusing if a full scan runs concurrently
            // It's better to handle upload scan results separately or ensure perform_full_scan resets it.
            // For now, we just error out.
            
            // Return error
            $file_array['error'] = 'File upload blocked: Malware detected (' . esc_html($reason) . ')';
            
            // To ensure the main scan_results isn't polluted by just upload scans if a full scan is running,
            // we might want to pop these new findings if they are only for the upload.
            // For now, this is okay as perform_full_scan resets self::$scan_results.
        }
        
        return $file_array;
    }

    public static function check_core_file_integrity() {
        global $wp_version;
        $locale = get_locale();

        // Fetch official checksums
        $url = sprintf('https://api.wordpress.org/core/checksums/1.0/?version=%s&locale=%s', $wp_version, $locale);
        $response = wp_remote_get($url, ['timeout' => 15]);

        if (is_wp_error($response) || wp_remote_retrieve_response_code($response) !== 200) {
            self::$scan_results[] = [
                'file' => 'WordPress Core Checksums',
                'type' => 'core_checksum_error',
                'severity' => 'warning', // Or 'medium'
                'details' => 'Could not retrieve official WordPress core file checksums. API request failed. Error: ' . (is_wp_error($response) ? $response->get_error_message() : wp_remote_retrieve_response_message($response)),
            ];
            error_log('SecureSphere Core Integrity: Failed to fetch checksums. Response: ' . print_r($response, true));
            return;
        }

        $body = wp_remote_retrieve_body($response);
        $official_checksums_data = json_decode($body, true);

        if (empty($official_checksums_data['checksums']) || !is_array($official_checksums_data['checksums'])) {
            self::$scan_results[] = [
                'file' => 'WordPress Core Checksums',
                'type' => 'core_checksum_error',
                'severity' => 'warning',
                'details' => 'Official WordPress core file checksums data is invalid or empty.',
            ];
            error_log('SecureSphere Core Integrity: Invalid or empty checksums data received. Body: ' . $body);
            return;
        }

        $official_checksums = $official_checksums_data['checksums'];
        $wp_root_path = ABSPATH;
        $scanned_local_files = [];

        // Iterate over expected core files from checksums
        foreach ($official_checksums as $relative_path => $expected_md5) {
            // Skip files that are not part of a standard installation or vary by default.
            // wp-content is generally excluded from core checksums by WP itself, but good to be explicit.
            if (strpos($relative_path, 'wp-content/') === 0 && $relative_path !== 'wp-content/index.php') {
                continue;
            }
            // wp-config.php is site-specific
            if ($relative_path === 'wp-config.php') {
                continue;
            }

            $local_file_path = $wp_root_path . $relative_path;
            $scanned_local_files[str_replace($wp_root_path, '', $local_file_path)] = true; // Mark as scanned

            if (!file_exists($local_file_path)) {
                self::$scan_results[] = [
                    'file' => $relative_path,
                    'type' => 'core_file_integrity',
                    'severity' => 'high',
                    'details' => 'WordPress core file is missing.',
                    'status' => 'missing',
                ];
            } else {
                $local_md5 = md5_file($local_file_path);
                if ($local_md5 !== $expected_md5) {
                    self::$scan_results[] = [
                        'file' => $relative_path,
                        'type' => 'core_file_integrity',
                        'severity' => 'critical',
                        'details' => 'WordPress core file has been modified. Hash mismatch.',
                        'status' => 'modified',
                        'expected_hash' => $expected_md5,
                        'actual_hash' => $local_md5,
                    ];
                }
            }
        }

        // Check for unexpected files in core directories (wp-admin, wp-includes, and root php files)
        // This is a simplified check; a more robust one would list all files and compare.
        $core_dirs_to_check = [ABSPATH . 'wp-admin/', ABSPATH . 'wp-includes/'];
        // Add root PHP files for checking (excluding wp-config.php which is user-specific)
        $root_files = glob(ABSPATH . '*.php');
        $files_to_scan_for_unexpected = [];

        foreach($core_dirs_to_check as $dir_path) {
            if (!is_dir($dir_path)) continue;
            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($dir_path, RecursiveDirectoryIterator::SKIP_DOTS),
                RecursiveIteratorIterator::SELF_FIRST
            );
            foreach ($iterator as $item) {
                if ($item->isFile()) {
                     $files_to_scan_for_unexpected[] = $item->getPathname();
                }
            }
        }
        if ($root_files) {
            foreach($root_files as $root_file) {
                if (basename($root_file) !== 'wp-config.php') {
                    $files_to_scan_for_unexpected[] = $root_file;
                }
            }
        }

        foreach ($files_to_scan_for_unexpected as $local_file_path) {
            $relative_path = str_replace($wp_root_path, '', $local_file_path);
            // If a file is present locally but not in the official checksums (and not wp-config)
            // and it's not a directory (already handled by isFile)
            if (!isset($official_checksums[$relative_path]) && $relative_path !== 'wp-config.php') {
                 // Further filter: ignore common non-core but acceptable files like .htaccess, .user.ini, error_log, etc.
                if (in_array(basename($relative_path), ['.htaccess', '.user.ini', 'error_log', 'php_errorlog', 'debug.log', 'wp-config-sample.php'])) {
                    continue;
                }
                // Exclude common dotfiles like .DS_Store, .gitignore, .git
                if (strpos(basename($relative_path), '.') === 0) {
                    continue;
                }

                self::$scan_results[] = [
                    'file' => $relative_path,
                    'type' => 'core_file_integrity',
                    'severity' => 'warning', // Or 'medium'
                    'details' => 'Unexpected file found in WordPress core directory/root.',
                    'status' => 'unexpected_file',
                ];
            }
        }
    }

    public static function check_outdated_components() {
        // Check WordPress Core
        // Ensure WordPress update-related files are loaded
        if (!function_exists('get_core_updates')) {
            require_once ABSPATH . 'wp-admin/includes/update.php';
        }
        wp_version_check(); // Forces an update check
        $core_updates = get_core_updates();
        if (!empty($core_updates) && is_array($core_updates)) {
            foreach ($core_updates as $core_update) {
                if (isset($core_update->response) && $core_update->response === 'update_available') {
                    self::$scan_results[] = [
                        'file' => 'WordPress Core', // Generic identifier
                        'type' => 'outdated_component',
                        'severity' => 'medium', // Or 'high' depending on policy
                        'details' => sprintf(
                            'WordPress version %s is outdated. Latest version is %s.',
                            get_bloginfo('version'),
                            $core_update->version
                        ),
                        'component_type' => 'core',
                        'current_version' => get_bloginfo('version'),
                        'new_version' => $core_update->version,
                    ];
                    break; // Only report one core update needed
                }
            }
        }

        // Check Plugins
        wp_update_plugins(); // Forces a plugin update check
        $all_plugins = get_plugins();
        $plugin_updates = get_plugin_updates();

        foreach ($all_plugins as $plugin_file => $plugin_data) {
            if (isset($plugin_updates[$plugin_file])) {
                $update_info = $plugin_updates[$plugin_file];
                self::$scan_results[] = [
                    'file' => $plugin_data['Name'] . ' (plugin)',
                    'type' => 'outdated_component',
                    'severity' => 'low', // Or 'medium'
                    'details' => sprintf(
                        'Plugin "%s" version %s is outdated. Latest version is %s.',
                        $plugin_data['Name'],
                        $plugin_data['Version'],
                        $update_info->update->new_version
                    ),
                    'component_type' => 'plugin',
                    'component_slug' => dirname($plugin_file),
                    'current_version' => $plugin_data['Version'],
                    'new_version' => $update_info->update->new_version,
                ];
            }
        }

        // Check Themes
        wp_update_themes(); // Forces a theme update check
        $all_themes = wp_get_themes();
        $theme_updates = get_theme_updates();

        foreach ($all_themes as $theme_slug => $theme_data) {
            if (isset($theme_updates[$theme_slug])) {
                $update_info = $theme_updates[$theme_slug];
                self::$scan_results[] = [
                    'file' => $theme_data->get('Name') . ' (theme)',
                    'type' => 'outdated_component',
                    'severity' => 'low', // Or 'medium'
                    'details' => sprintf(
                        'Theme "%s" version %s is outdated. Latest version is %s.',
                        $theme_data->get('Name'),
                        $theme_data->get('Version'),
                        $update_info->update['new_version']
                    ),
                    'component_type' => 'theme',
                    'component_slug' => $theme_slug,
                    'current_version' => $theme_data->get('Version'),
                    'new_version' => $update_info->update['new_version'],
                ];
            }
        }
    }

    public static function load_signatures_from_db($type = null) {
        global $wpdb;
        $table_name = $wpdb->prefix . 'securesphere_malware_signatures';
        $sql = "SELECT signature_id, type, pattern, description, severity FROM {$table_name}";
        $params = [];

        if ($type !== null) {
            $sql .= " WHERE type = %s";
            $params[] = $type;
        }

        $results = $wpdb->get_results($wpdb->prepare($sql, $params), ARRAY_A);

        if ($wpdb->last_error) {
            error_log("SecureSphere DB Error loading signatures: " . $wpdb->last_error);
            return [];
        }
        return $results ?: [];
    }

    // private static function load_yara_rules() { // Deprecated
    // }

    // private static function match_yara_rule($content, $rule) { // Deprecated by new signature system
    //     return preg_match($rule['pattern'], $content) === 1;
    // }

    private static function has_hardcoded_suspicious_patterns($content) {
        // This method is kept for now, but its patterns should ideally be migrated to the signatures DB.
        if (empty($content)) return false; // Avoid warnings on empty content for preg_match

        $patterns = [ // These are basic examples
            '/eval\s*\(\s*base64_decode\s*\(/i',
            '/shell_exec\s*\(/i',
            '/passthru\s*\(/i',
            '/system\s*\(/i',
            '/proc_open\s*\(/i',
            '/popen\s*\(/i',
            '/<\?php\s+filesize\s*\(\s*__FILE__\s*\)\s*==\s*0\s*\?\s*include\s*\(\s*\$_(GET|POST|REQUEST|COOKIE)/i', // Common backdoor pattern
            '/\$GLOBALS\[\$GLOBALS\[\'[a-zA-Z0-9_]*\'\]\]/i', // Superglobals manipulation
        ];

        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $content)) {
                return true;
            }
        }
        return false;
    }

    // is_known_malware_hash is now implicitly handled in scan_file by checking OPT_KNOWN_MALWARE_HASHES

    public static function add_malware_scan_menu() { // Renamed
        add_submenu_page(
            'securesphere-mssp',
            'Malware Scanner', // Page Title
            'Malware Scan',    // Menu Title
            'manage_options',
            'securesphere-malware-scan', // Slug
            [__CLASS__, 'render_malware_scan_page'] // Renamed
        );
    }

    public static function render_malware_scan_page() { // Renamed
        if (!current_user_can('manage_options')) {
            wp_die('Permission Denied.');
        }

        // Handle settings update
        if (isset($_POST['securesphere_malware_settings_nonce']) && wp_verify_nonce($_POST['securesphere_malware_settings_nonce'], 'securesphere_malware_settings_action')) {
            update_option(self::OPT_SCAN_UPLOADS_ENABLED, isset($_POST[self::OPT_SCAN_UPLOADS_ENABLED]));
            update_option(self::OPT_SCHEDULE_ENABLED, isset($_POST[self::OPT_SCHEDULE_ENABLED]));
            if (isset($_POST[self::OPT_SCHEDULE_FREQUENCY])) {
                $new_freq = sanitize_text_field($_POST[self::OPT_SCHEDULE_FREQUENCY]);
                $current_freq = get_option(self::OPT_SCHEDULE_FREQUENCY, 'daily');
                if ($new_freq !== $current_freq || (isset($_POST[self::OPT_SCHEDULE_ENABLED]) && !wp_next_scheduled('securesphere_scheduled_scan_hook'))) {
                    wp_clear_scheduled_hook('securesphere_scheduled_scan_hook'); // Clear existing before rescheduling
                    update_option(self::OPT_SCHEDULE_FREQUENCY, $new_freq);
                    if (isset($_POST[self::OPT_SCHEDULE_ENABLED])) { // Only schedule if master schedule is enabled
                         self::schedule_scan_job(); // Reschedule with new frequency
                    }
                } elseif (!isset($_POST[self::OPT_SCHEDULE_ENABLED])) { // If schedule disabled, clear it
                     wp_clear_scheduled_hook('securesphere_scheduled_scan_hook');
                }
            }
            
            if (isset($_POST[self::OPT_CUSTOM_REGEX_PATTERNS])) {
                $custom_patterns = array_map('sanitize_textarea_field', explode("\n", $_POST[self::OPT_CUSTOM_REGEX_PATTERNS]));
                $custom_patterns = array_map('trim', $custom_patterns);
                $custom_patterns = array_filter($custom_patterns); // Remove empty lines
                update_option(self::OPT_CUSTOM_REGEX_PATTERNS, $custom_patterns);
            }
            //  if (isset($_POST[self::OPT_KNOWN_MALWARE_HASHES])) { // Placeholder - Deprecating this option field
            //     $known_hashes = array_map('sanitize_text_field', explode("\n", $_POST[self::OPT_KNOWN_MALWARE_HASHES]));
            //     $known_hashes = array_map('trim', $known_hashes);
            //     $known_hashes = array_filter($known_hashes);
            //     update_option(self::OPT_KNOWN_MALWARE_HASHES, $known_hashes);
            // }

            echo '<div class="notice notice-success is-dismissible"><p>Settings saved.</p></div>';
            self::load_settings_and_hooks(); // Reload hooks if settings changed
        }

        $scan_uploads_enabled = get_option(self::OPT_SCAN_UPLOADS_ENABLED, true);
        $schedule_enabled = get_option(self::OPT_SCHEDULE_ENABLED, true);
        $schedule_frequency = get_option(self::OPT_SCHEDULE_FREQUENCY, 'daily');
        $custom_regex_patterns = get_option(self::OPT_CUSTOM_REGEX_PATTERNS, []);
        // $known_malware_hashes = get_option(self::OPT_KNOWN_MALWARE_HASHES, []); // Deprecated

        $last_scan = get_option(self::OPT_LAST_SCAN, []);
        $last_sig_update = get_option('securesphere_last_signature_update_time', 'Never');
        $sig_version = get_option('securesphere_signature_version', 'N/A');
        $sig_update_status_transient = get_transient('securesphere_sig_update_status');
        ?>
        <div class="wrap">
            <h1>Malware Scanner Settings & Results</h1>

            <?php if ($sig_update_status_transient): ?>
                <?php
                $status_parts = explode('_', $sig_update_status_transient);
                $status_type = $status_parts[0];
                if ($status_type === 'success'):
                    $inserted = $status_parts[2];
                    $updated = $status_parts[4];
                ?>
                    <div class="notice notice-success is-dismissible">
                        <p>Signature update successful. Inserted: <?php echo esc_html($inserted); ?>, Updated: <?php echo esc_html($updated); ?>.</p>
                    </div>
                <?php elseif (strpos($sig_update_status_transient, 'error_') === 0): ?>
                    <div class="notice notice-error is-dismissible">
                        <p>Signature update error: <?php echo esc_html(str_replace('error_', '', $sig_update_status_transient)); ?>. Check PHP error logs for details.</p>
                    </div>
                <?php endif; ?>
                <?php delete_transient('securesphere_sig_update_status'); ?>
            <?php endif; ?>

            <form method="post" action="">
                <?php wp_nonce_field('securesphere_malware_settings_action', 'securesphere_malware_settings_nonce'); ?>
                <h2>Scan Settings</h2>
                <table class="form-table">
                    <tr valign="top">
                        <th scope="row">Scan Uploaded Files</th>
                        <td><input type="checkbox" name="<?php echo self::OPT_SCAN_UPLOADS_ENABLED; ?>" value="1" <?php checked($scan_uploads_enabled); ?> /> Enable real-time scanning of uploaded files.</td>
                    </tr>
                    <tr valign="top">
                        <th scope="row">Enable Scheduled Scans</th>
                        <td><input type="checkbox" name="<?php echo self::OPT_SCHEDULE_ENABLED; ?>" value="1" <?php checked($schedule_enabled); ?> /> Enable automatic periodic scans of your site.</td>
                    </tr>
                    <tr valign="top">
                        <th scope="row"><label for="<?php echo self::OPT_SCHEDULE_FREQUENCY; ?>">Scan Frequency</label></th>
                        <td>
                            <select name="<?php echo self::OPT_SCHEDULE_FREQUENCY; ?>" id="<?php echo self::OPT_SCHEDULE_FREQUENCY; ?>">
                                <?php
                                $schedules = wp_get_schedules();
                                foreach ($schedules as $key => $details) {
                                    echo '<option value="' . esc_attr($key) . '" ' . selected($schedule_frequency, $key, false) . '>' . esc_html($details['display']) . '</option>';
                                }
                                ?>
                            </select>
                            <p class="description">How often should scheduled scans run?</p>
                        </td>
                    </tr>
                    <tr valign="top">
                        <th scope="row"><label for="<?php echo self::OPT_CUSTOM_REGEX_PATTERNS; ?>">Custom Regex Patterns</label></th>
                        <td>
                            <textarea name="<?php echo self::OPT_CUSTOM_REGEX_PATTERNS; ?>" id="<?php echo self::OPT_CUSTOM_REGEX_PATTERNS; ?>" rows="5" cols="50" class="large-text code"><?php echo esc_textarea(implode("\n", $custom_regex_patterns)); ?></textarea>
                            <p class="description">Enter custom regular expression patterns to search for, one per line. Use with caution, invalid regex can cause errors.</p>
                        </td>
                    </tr>
                    <?php /* Deprecating Known Malware Hashes field - will be managed by signature system
                     <tr valign="top">
                        <th scope="row"><label for="<?php echo self::OPT_KNOWN_MALWARE_HASHES; ?>">Known Malware Hashes (MD5)</label></th>
                        <td>
                            <textarea name="<?php echo self::OPT_KNOWN_MALWARE_HASHES; ?>" id="<?php echo self::OPT_KNOWN_MALWARE_HASHES; ?>" rows="5" cols="50" class="large-text code"><?php echo esc_textarea(implode("\n", $known_malware_hashes)); ?></textarea>
                            <p class="description">Enter known MD5 hashes of malware files, one per line. (This is a placeholder for a proper hash database).</p>
                        </td>
                    </tr>
                    */ ?>
                </table>
                <?php submit_button('Save Settings'); ?>
            </form>
            <hr/>
            <h2>Scan Status & Manual Scan</h2>
            <p>
                Last Signature Update: <?php echo esc_html($last_sig_update); ?><br>
                Signature Version: <?php echo esc_html($sig_version); ?><br>
                Next Scheduled Scan: <?php echo esc_html(wp_next_scheduled('securesphere_scheduled_scan_hook') ? date('Y-m-d H:i:s', wp_next_scheduled('securesphere_scheduled_scan_hook')) : 'Not Scheduled'); ?><br>
                Next Signature Update: <?php echo esc_html(wp_next_scheduled('securesphere_daily_signature_update_hook') ? date('Y-m-d H:i:s', wp_next_scheduled('securesphere_daily_signature_update_hook')) : 'Not Scheduled'); ?>
            </p>

             <?php if (isset($_GET['scan_status']) && $_GET['scan_status'] === 'completed'): ?>
                <div class="notice notice-success is-dismissible"><p>Manual scan completed.</p></div>
            <?php endif; ?>

            <form method="post" action="<?php echo esc_url(admin_url('admin-post.php')); ?>" style="margin-bottom: 20px;">
                <input type="hidden" name="action" value="securesphere_run_manual_scan">
                <?php wp_nonce_field('securesphere_run_manual_scan_nonce', 'securesphere_manual_scan_nonce'); ?>
                <?php submit_button('Run Full Scan Now', 'primary', 'run_manual_scan_button'); ?>
            </form>

            <h2>Latest Scan Results</h2>
            <?php if (empty($last_scan)): ?>
                <p>No scan has been performed yet.</p>
            <?php else: ?>
                <p>Last scan performed at: <?php echo esc_html($last_scan['time']); ?> (Type: <?php echo esc_html(ucfirst($last_scan['type'] ?? 'N/A')); ?>)</p>
                
                <?php if (empty($last_scan['results'])): ?>
                    <div class="notice notice-success is-dismissible"><p>No threats detected in the last scan.</p></div>
                <?php else: ?>
                    <table class="wp-list-table widefat fixed striped">
                        <thead>
                            <tr>
                                <th>File</th>
                                <th>Type</th>
                                <th>Severity</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody>
                            <?php foreach ($last_scan['results'] as $result): ?>
                                <?php
                                $display_type = ucwords(str_replace('_', ' ', $result['type']));
                                $details = esc_html($result['details']);

                                if ($result['type'] === 'outdated_component') {
                                    $display_type = 'Outdated Component';
                                    $details = sprintf(
                                        'Component: %s (%s). Installed: %s, Latest: %s. %s',
                                        esc_html($result['file']),
                                        esc_html($result['component_type'] ?? 'N/A'),
                                        esc_html($result['current_version'] ?? 'N/A'),
                                        esc_html($result['new_version'] ?? 'N/A'),
                                        esc_html($result['details'])
                                    );
                                } elseif ($result['type'] === 'core_file_integrity') {
                                    $display_type = 'Core File Integrity';
                                    $status_text = isset($result['status']) ? 'Status: ' . ucfirst(esc_html($result['status'])) . '. ' : '';
                                    $details = $status_text . esc_html($result['details']);
                                    if (isset($result['status']) && $result['status'] === 'modified') {
                                        $details .= sprintf(
                                            ' (Expected MD5: %s, Actual MD5: %s)',
                                            esc_html($result['expected_hash'] ?? 'N/A'),
                                            esc_html($result['actual_hash'] ?? 'N/A')
                                        );
                                    }
                                } elseif ($result['type'] === 'core_checksum_error') {
                                    $display_type = 'Core Checksum Error';
                                }

                                ?>
                                <tr>
                                    <td><?php echo esc_html($result['file']); ?></td>
                                    <td><?php echo esc_html($display_type); ?></td>
                                    <td>
                                        <span class="severity-<?php echo esc_attr(strtolower($result['severity'])); ?>">
                                            <?php echo esc_html(ucfirst($result['severity'])); ?>
                                        </span>
                                    </td>
                                    <td><?php echo $details; // Already escaped ?></td>
                                </tr>
                            <?php endforeach; ?>
                        </tbody>
                    </table>
                <?php endif; ?>
            <?php endif; ?>
        </div>
        <?php
    }
}